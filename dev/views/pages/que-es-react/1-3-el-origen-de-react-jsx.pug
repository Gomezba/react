extends ../../templates/template 

append h1 
    h1 El origen de React y JSX

append content 
    article(id="1" class="content")
        h2 Consecuencias de XHP 
        p Con XHP, Facebook parecía estar en una mejor situación: tenían un sistema estable y predecible, y sus servidores pasaban el día renderizando estas plantillas. Sin embargo, ahí surgió un nuevo problema: para cualquier pequeño cambio en la vista, cada acción del usuario generaba una llamada inmediata al servidor.

        p Este enfoque resultaba ineficiente, ya que incluso las interacciones más simples requerían un procesamiento en el servidor, lo que impactaba negativamente en el rendimiento y la escalabilidad de la plataforma.


    article(id="2" class="content")
        h2 Saturación 

        p El escenario era complicado: millones de peticiones al servidor, las conexiones de red de aquel entonces, y el rendimiento limitado de PHP, que siempre había sido un problema. Además, aunque XHP facilitaba el desarrollo, empeoraba el rendimiento en comparación con las plantillas creadas con strings. Los servidores estaban sobrecargados.
        img(src="../../assets/img/1-3-el-origen-de-react-jsx/1.webp" alt="saturacion").img-md

        p La mayoría de estas peticiones al servidor eran simplemente para actualizar la vista, lo que generaba una carga de trabajo innecesaria para una tarea tan sencilla. ¿Cómo se podía evitar tantas llamadas innecesarias? La respuesta a esta pregunta cambió la web tal como la conocemos hoy en día: 
            strong utilizando JavaScript.

    article(id="3" class="content")
        h2 JavaScript
        p JavaScript permitió reducir muchas de las llamadas al servidor que solo tenían como objetivo actualizar la vista. Ahora, las actualizaciones podían realizarse directamente en el navegador del usuario, utilizando su CPU y memoria RAM. Aunque algunas actualizaciones seguían requiriendo comunicación con el servidor, muchas otras podían gestionarse en el cliente, lo que alivió la carga del servidor y mejoró significativamente la escalabilidad del sistema.
        img(src="../../assets/img/1-3-el-origen-de-react-jsx/2.webp" alt="javascript").img-md

        h3 Dividir la lógica 
        p La idea de utilizar JavaScript parecía muy buena, pero presentó un nuevo desafío: dividir la lógica de la aplicación entre dos lenguajes, PHP y JavaScript. Originalmente, tanto el renderizado de las plantillas como la lógica del servidor estaban escritos en PHP. En este nuevo enfoque, el renderizado de las vistas tenía que ser gestionado por JavaScript, mientras que la lógica puramente de servidor podía seguir en PHP.

        p El problema era que ya no podían utilizar XHP para crear las plantillas, ya que no era compatible con JavaScript. Esto obligó a replantear cómo estructurar la lógica y el renderizado de las vistas en esta nueva arquitectura.
        img(src="../../assets/img/1-3-el-origen-de-react-jsx/3.webp" alt="javascript")

        h3 Fax JS - Jordan Walke, 2011
        p En 2011, Jordan Walke, ingeniero de Facebook, decidió crear Fax JS, una librería que permitía la creación de plantillas en JavaScript de manera muy similar a como se hacía con XHP. Esta fue la semilla de un proyecto que hoy conocemos con otro nombre: 
            span.ts-5 React (A JavaScript library for building user interfaces)
            | .

        p Al desarrollar esta nueva librería, el equipo aprovechó toda su experiencia previa. Aprendieron de los errores que habían cometido y potenciaron los aciertos, creando una herramienta más eficiente y adecuada para los desafíos que enfrentaban.

    article(id="4" class="content")
        h2 JSX vs XHP
        p La primera característica que buscaban en React era una sintaxis intuitiva. Basándose en XHP, idearon una sintaxis que permitiera escribir componentes de una manera aún más similar a HTML. Esta sintaxis, conocida hoy en día como JavaScript XML (JSX), refleja claramente la inspiración que tomaron de XHP.
        img(src="../../assets/img/1-3-el-origen-de-react-jsx/4.webp" alt="javascript").img-md

    article(id="5" class="content")
        h2 Etiquetas JSX
        p Además, buscaban una forma sencilla de combinar componentes, creando componentes más grandes a partir de otros más pequeños, y que este proceso fuera aún más fácil de entender que con XHP. En este contexto, si bien JSX ya se parecía bastante a HTML, su objetivo era hacerlo aún más parecido. En lugar de tratar los componentes como variables, los diseñaron para que se comportaran como etiquetas dentro de las plantillas. De esta manera, el código se asemejaba aún más al HTML estándar.

        div.has-mb: pre: code.language-jsx 
            |&lt;App&gt;
            |    &lt;CustomHeader/&gt;
            |        &lt;main&gt;
            |            &lt;h1&gt;Gomezba&lt;/h1&gt;
            |        &lt;/main&gt;
            |    &lt;CustomFooter/&gt;
            |&lt;/App&gt;        

    article(id="6" class="content")
        h2 Lógica y vista todo en uno 
        p Finalmente, decidieron agrupar la lógica y la plantilla JSX en un solo archivo, en lugar de separarlos en varios. Esto permite al desarrollador tener todo el contexto del componente en un solo lugar, sin necesidad de abrir varios archivos a la vez. Esta integración facilita el trabajo y mejora la comprensión del código.

        div: pre: code.language-jsx
            |//Button.jsx

            |const Button = () =>{
            |    return &lt;button onClick={onClick}&gt;Click&lt;/button&gt;
            |}

            |const onClick = () =&gt; alert('Gomezba')    

append submenu 
    -submenuLinks = [[1,'Consecuencias de XHP'],[2,'Saturación'],[3,'JavaScript'],[4,'JSX vs XHP'],[5,'Etiquetas JSX'],[6,'Lógica y vista todo en uno']]
    +submenu(submenuLinks)